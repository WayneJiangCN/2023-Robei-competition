`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2023/04/10 22:33:01
// Design Name: 
// Module Name: US_100
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module US_100(
	sys_clk,
	sys_rst,
	echo,
	trig,
	en,
	en_led,
	data_en,
	data);

	//---Ports declearation: generated by Robei---
	input sys_clk;
	input sys_rst;
	input echo;
	output trig;
	output en;
	output en_led;
	output data;
	output data_en;

	wire sys_clk;
	wire sys_rst;
	wire echo;
	wire trig;
	reg en;
	reg en_led;
	reg data_en;
	wire [7:0]  data;
		//参数
    parameter           TIME_1S = 50_000_000;
    parameter           TIME_0D9S = 45_000_000;
    	//内部信号
    reg [25:0]              cnt;
    reg  [7:0]  distance;
    		//1s计数
    always  @(posedge sys_clk or negedge sys_rst)begin
        if(sys_rst==1'b0)begin
            cnt <= 26'd0;
        end
        else begin
            if(cnt >= TIME_1S)
                cnt <= 26'd0;
            else
                cnt <= cnt + 1'd1;
        end
    end

	//----Code starts here: integrated by Robei-----
		reg  [21:0]  period_cnt;      //trig信号周期计数器的计数值60ms*50MHz=3000000
		
			reg  [20:0]  echo_cnt;              //echo信号高电平时间计数器
			reg  [20:0]  echo_reg; //echo信号高电平时间寄存器
			reg  echo_reg1;                     //echo信号寄存器1
			reg  echo_reg2;                     //echo信号寄存器2
			
			reg  [2:0]   state;
			parameter S0=3'b001;
			parameter S1=3'b010;
			parameter S2=3'b100;
			
			wire  start;
			wire  finish;
			
			assign	trig   = (period_cnt >= 22'd500) ? 1'b0 : 1'b1;  //trig信号的高电平时间10us*50MHz=500
			assign	start  = echo_reg1 & ~echo_reg2;   //捕获echo信号posedge
			assign	finish = ~echo_reg1 & echo_reg2;   //捕获echo信号negedge
		
			//trig信号周期计数器
			always @(posedge sys_clk or negedge sys_rst) begin
			    if(!sys_rst)
			        period_cnt <= 22'd0;
			    else if(period_cnt == 22'd3000000)
			        period_cnt <= 22'd0;
			    else
			        period_cnt <= period_cnt + 1'b1;
			end
		
			//捕获echo信号posedge和negedge
			//输入的单bit信号打两拍进行异步处理
			always @(posedge sys_clk or negedge sys_rst) begin
			    if(!sys_rst) begin
			        echo_reg1 <= 1'b0;
					echo_reg2 <= 1'b0;
				end
			    else begin
					echo_reg1 <= echo;
					echo_reg2 <= echo_reg1;
				end
			end	
		
			//状态机用于记录echo信号高电平时间	
			always @(posedge sys_clk or negedge sys_rst) begin
			    if(!sys_rst) begin
					state <= S0;
					echo_cnt <= 21'b0;
					echo_reg<=21'd50000;
			    end    
			    else begin
					case(state)
						S0: begin
							if(start)
								state <= S1;
							else
								state <= S0;
						end
						S1: begin
							if(finish)
								state <= S2;
							else begin
								echo_cnt <= echo_cnt + 1'b1;
								state <= S1;
							end
						end
						S2: begin
							echo_cnt <= 1'b0;
							echo_reg <= echo_cnt;
							state <= S0;
						end
						default: state <= S0;
					endcase
				end
			end
			
			//距离监测	
			always @(posedge sys_clk or negedge sys_rst) begin
			    if(!sys_rst) begin
					en <= 1'b0;
					en_led <= 1'b0;
			    end    
			    else begin
					if(echo_reg < 21'd50000) begin		 //距离小于17cm,高电平1ms*50MHz=50000
						en <= 1'b1;                       //distance = echo_reg/0.0005*
						en_led <= 1'b1;
					end
					else begin
						en <= 1'b0;
						en_led <= 1'b0;
					end
				end
			end	
					//在1s快结束前进行距离计算 S = [(echo的高电平时间)* 340m/s]/2  这里注意单位
            always  @(posedge sys_clk or negedge sys_rst)begin
                if(!sys_rst)begin
                    distance <= 8'b0;
                end
                else if(cnt == TIME_0D9S-1 ) begin
                    distance <= echo_reg*34/10000 ; //单位mm
                end
            end		//数据赋值
                assign data = distance;
                
                //每一秒发送一次数据
                always  @(posedge sys_clk or negedge sys_rst)begin
                    if(!sys_rst)begin
                        data_en <= 1'b0;
                    end
                    else if(cnt == TIME_1S-1) begin
                        data_en <= 1'b1;
                    end
                    else
                        data_en <= 1'b0;
                end
//wire [2:0] state_1;
//wire [20:0]echo_reg_1;
//assign state_1 = state;
//assign echo_reg_1 = echo_reg;
//ila_0 u_ila_0 (
//                    .clk(sys_clk), // input wire clk
                
                
//                    .probe0(state_1), // input wire [2:0]  probe0  
//                    .probe1(echo_reg_1) // input wire [20:0]  probe1
//                );
//                );
endmodule    //us_100m


