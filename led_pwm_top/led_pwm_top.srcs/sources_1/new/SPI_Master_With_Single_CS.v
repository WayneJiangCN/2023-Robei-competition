module SPI_Master_With_Single_CS(
	i_Rst_L,   
	i_Clk,
	i_TX_Count,
	i_TX_Byte,
	i_TX_DV,
	i_SPI_MISO,
	o_TX_Ready, //准备发送标志位
	o_RX_Count, 
	o_RX_DV,  //采样结束，数据有效标志位
	o_RX_Byte,
	o_SPI_Clk,
	o_SPI_MOSI,
	o_SPI_CS_n);

	//----Parameters:: generated by Robei-----
	parameter SPI_MODE = 0;
	parameter CLKS_PER_HALF_BIT = 2;
	parameter MAX_BYTES_PER_CS = 2;
	parameter CS_INACTIVE_CLKS = 1;

	//---Ports declearation: generated by Robei---
	input i_Rst_L; 
	input i_Clk;
	input [1:0] i_TX_Count;
	input [7:0] i_TX_Byte;
	input i_TX_DV;
	input i_SPI_MISO;
	output o_TX_Ready;
	output [1:0] o_RX_Count;
	output o_RX_DV;
	output [7:0] o_RX_Byte;
	output o_SPI_Clk;
	output o_SPI_MOSI;
	output o_SPI_CS_n;

	wire i_Rst_L;  //复位
	wire i_Clk;    //系统时钟
	wire [1:0] i_TX_Count;
	wire [7:0] i_TX_Byte;
	wire i_TX_DV;
	wire i_SPI_MISO;
	wire o_TX_Ready;
	reg [1:0] o_RX_Count;
	wire o_RX_DV;
	wire [7:0] o_RX_Byte;
	wire o_SPI_Clk;
	wire o_SPI_MOSI;
	wire o_SPI_CS_n;

	//----Code starts here: integrated by Robei-----
	  localparam IDLE        = 2'b00;
	  localparam TRANSFER    = 2'b01;
	  localparam CS_INACTIVE = 2'b10;
	
	  reg [1:0] r_SM_CS;
	  reg r_CS_n;
	  reg [6:0] r_CS_Inactive_Count;//[$clog2(CS_INACTIVE_CLKS)-1:0]
	  reg [1:0] r_TX_Count;//[$clog2(MAX_BYTES_PER_CS+1)-1:0]
	  wire w_Master_Ready;
	
	  // Purpose: Control CS line using State Machine 使用状态机控制CS线
	  always @(posedge i_Clk or negedge i_Rst_L) 
	  begin
	    if (~i_Rst_L)
	    begin
	      r_SM_CS <= IDLE;
	      r_CS_n  <= 1'b1;   // Resets to high
	      r_TX_Count <= 0;
	      r_CS_Inactive_Count <= CS_INACTIVE_CLKS;
	    end
	    else
	    begin
	
	      case (r_SM_CS)      
	      IDLE:
	        begin
	          if (r_CS_n & i_TX_DV) // Start of transmission
	          begin
	            r_TX_Count <= i_TX_Count - 1; // Register TX Count
	            r_CS_n     <= 1'b0;       // Drive CS low
	            r_SM_CS    <= TRANSFER;   // Transfer bytes
	          end
	        end
	
	      TRANSFER:   //转移
	        begin
	          // Wait until SPI is done transferring do next thing
	          if (w_Master_Ready)
	          begin
	            if (r_TX_Count > 0)
	            begin
	              if (i_TX_DV)
	              begin
	                r_TX_Count <= r_TX_Count - 1;
	              end
	            end
	            else
	            begin
	              r_CS_n  <= 1'b1; // we done, so set CS high
	              r_CS_Inactive_Count <= CS_INACTIVE_CLKS;
	              r_SM_CS             <= CS_INACTIVE;
	            end // else: !if(r_TX_Count > 0)
	          end // if (w_Master_Ready)
	        end // case: TRANSFER
	
	      CS_INACTIVE:
	        begin
	          if (r_CS_Inactive_Count > 0)
	          begin
	            r_CS_Inactive_Count <= r_CS_Inactive_Count - 1'b1;
	          end
	          else
	          begin
	            r_SM_CS <= IDLE;
	          end
	        end
	
	      default:
	        begin
	          r_CS_n  <= 1'b1; // we done, so set CS high
	          r_SM_CS <= IDLE;
	        end
	      endcase // case (r_SM_CS)
	    end
	  end // always @ (posedge i_Clk or negedge i_Rst_L)
	
	
	  // Purpose: Keep track of RX_Count
	  always @(posedge i_Clk)
	  begin
	    begin
	      if (r_CS_n)
	      begin
	        o_RX_Count <= 0;
	      end
	      else if (o_RX_DV)
	      begin
	        o_RX_Count <= o_RX_Count + 1'b1;
	      end
	    end
	  end
	
	  assign o_SPI_CS_n = r_CS_n;
	
	  assign o_TX_Ready  = ((r_SM_CS == IDLE) | (r_SM_CS == TRANSFER && w_Master_Ready == 1'b1 && r_TX_Count > 0)) & ~i_TX_DV;
	
	
	//---Module instantiation---
	SPI_Master #( 0, 2) SPI_Master1(
		.i_Rst_L(i_Rst_L),
		.i_Clk(i_Clk),
		.i_TX_Byte(i_TX_Byte),
		.i_TX_DV(i_TX_DV),
		.i_SPI_MISO(i_SPI_MISO),
		.o_TX_Ready(w_Master_Ready),
		.o_RX_DV(o_RX_DV),
		.o_RX_Byte(o_RX_Byte),
		.o_SPI_Clk(o_SPI_Clk),
		.o_SPI_MOSI(o_SPI_MOSI));

endmodule    //SPI_Master_With_Single_CS

